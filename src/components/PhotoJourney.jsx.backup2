import { motion, useScroll, useTransform, animate } from 'framer-motion'
import { useRef, useState, useEffect } from 'react'

export default function PhotoJourney() {
  const containerRef = useRef(null)
  const [currentStep, setCurrentStep] = useState(0) 
  const [isAnimating, setIsAnimating] = useState(false)
  const [manualProgress, setManualProgress] = useState(0)
  
  const { scrollYProgress } = useScroll({
    target: containerRef,
    offset: ['start start', 'end end']
  })

  // BLOCKIERE SCROLL während Animation!
  useEffect(() => {
    if (isAnimating) {
      document.body.style.overflow = 'hidden'
    } else {
      document.body.style.overflow = 'auto'
    }
    return () => { document.body.style.overflow = 'auto' }
  }, [isAnimating])

  // Cinematische Animation mit STOPS für Texte/Fotos
  const triggerNextStep = async () => {
    if (isAnimating) return
    setIsAnimating(true)
    
    if (currentStep === 0) {
      // Phase 1: Rechts → Vollbild (4.5s)
      await animate(manualProgress, manualProgress + 1, {
        duration: 4.5,
        ease: [0.16, 1, 0.3, 1],
        onUpdate: setManualProgress
      })
      setCurrentStep(1)
      
    } else if (currentStep === 1) {
      // Phase 2: Vollbild → Links (4.5s) 
      await animate(manualProgress, manualProgress + 1, {
        duration: 4.5,
        ease: [0.16, 1, 0.3, 1],
        onUpdate: setManualProgress
      })
      setCurrentStep(2)
      
    } else if (currentStep === 2) {
      // Phase 3: Links → Mitte → Perfekter Kreis → Verschwindet (6s)
      await animate(manualProgress, manualProgress + 1, {
        duration: 6.0,
        ease: [0.12, 1, 0.25, 1],
        onUpdate: setManualProgress
      })
      setCurrentStep(3)
    }
    
    setIsAnimating(false)
  }

  // Scroll-Trigger für nächste Phase
  useEffect(() => {
    if (isAnimating) return
    
    const unsubscribe = scrollYProgress.on('change', (latest) => {
      if (latest > 0.01 && currentStep < 3) {
        triggerNextStep()
      }
    })
    
    return unsubscribe
  }, [scrollYProgress, currentStep, isAnimating])

  // CINEMATISCHE CLIP-PATH ANIMATION mit perfektem Kreis
  const getClipPath = (progress) => {
    if (progress <= 1) {
      // Phase 1: Rechte Ellipse → Vollbild
      const t = progress
      const rx = 60 + (40 * t) // 60% → 100%
      const ry = 40 + (60 * t) // 40% → 100%
      const x = 90 - (40 * t)  // 90% → 50%
      return `ellipse(${rx}% ${ry}% at ${x}% 50%)`
      
    } else if (progress <= 2) {
      // Phase 2: Vollbild → Linke Ellipse
      const t = progress - 1
      const rx = 100 - (40 * t) // 100% → 60% 
      const ry = 100 - (60 * t) // 100% → 40%
      const x = 50 - (40 * t)   // 50% → 10%
      return `ellipse(${rx}% ${ry}% at ${x}% 50%)`
      
    } else {
      // Phase 3: Links → Mitte → PERFEKTER KREIS → Verschwindet
      const t = progress - 2
      
      if (t <= 0.5) {
        // 3a: Links → Mitte
        const subT = t * 2
        const rx = 60
        const ry = 40  
        const x = 10 + (40 * subT) // 10% → 50%
        return `ellipse(${rx}% ${ry}% at ${x}% 50%)`
        
      } else {
        // 3b: Mitte → Perfekter Kreis → Verschwindet
        const subT = (t - 0.5) * 2
        
        if (subT <= 0.6) {
          return `ellipse(${rx}% ${ry}% at 50% 50%)`
          return `ellipse(${rx}% ${ry}% at 50% 50%)`
          return `ellipse(${rx}% ${ry}% at 50% 50%)`
          return `ellipse(${rx}% ${ry}% at 50% 50%)`
          return `ellipse(${rx}% ${ry}% at 50% 50%)`
          return `ellipse(${rx}% ${ry}% at 50% 50%)`
          return `ellipse(${rx}% ${ry}% at 50% 50%)`
          return `ellipse(${rx}% ${ry}% at 50% 50%)`
          return `ellipse(${rx}% ${ry}% at 50% 50%)`
